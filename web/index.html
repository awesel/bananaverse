<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>BananaVerse</title>
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üçå</text></svg>"
    />
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto,
          Helvetica, Arial, sans-serif;
        margin: 0;
        background: #0b0c10;
        color: #eaeaea;
      }
      header {
        background: #1f2833;
        padding: 16px 24px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        position: sticky;
        top: 0;
      }
      h1 {
        margin: 0;
        font-size: 18px;
        letter-spacing: 0.5px;
      }
      .container {
        padding: 16px 24px;
        display: grid;
        grid-template-columns: 380px 1fr;
        gap: 24px;
      }
      textarea {
        width: 100%;
        min-height: 200px;
        padding: 12px;
        border-radius: 8px;
        border: 1px solid #3a4750;
        background: #0f1115;
        color: #eaeaea;
        font-family: inherit;
        font-size: 14px;
        line-height: 1.5;
        resize: vertical;
        box-sizing: border-box;
      }
      button {
        background: #66fcf1;
        border: none;
        color: #0b0c10;
        font-weight: 700;
        padding: 12px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s ease;
      }
      button:hover:not(:disabled) {
        background: #45b7b8;
        transform: translateY(-1px);
      }
      button:disabled {
        background: #2b7a78;
        cursor: not-allowed;
        opacity: 0.6;
      }
      .generating {
        background: #f39c12 !important;
        color: #ffffff !important;
        transform: none !important;
      }
      .generating:hover {
        background: #f39c12 !important;
        transform: none !important;
      }
      .panel {
        background: #0f1115;
        border: 1px solid #3a4750;
        border-radius: 12px;
        padding: 16px;
      }
      .panel h3 {
        margin-top: 0;
        margin-bottom: 12px;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        justify-content: space-between;
        margin-top: 8px;
      }
      .status {
        font-size: 12px;
        color: #9aa5b1;
      }
      .assets {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
        margin-top: 16px;
      }
      select {
        width: 100%;
        padding: 10px;
        border-radius: 8px;
        background: #0f1115;
        color: #eaeaea;
        border: 1px solid #3a4750;
        font-size: 14px;
        box-sizing: border-box;
      }
      label {
        display: block;
        margin-bottom: 6px;
        font-size: 13px;
        font-weight: 600;
        color: #c9d1d9;
      }
      img {
        max-width: 100%;
        border-radius: 8px;
        background: #121419;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
        gap: 12px;
        margin-top: 12px;
      }
      .thumb {
        background: #0b0c10;
        border: 1px solid #3a4750;
        border-radius: 8px;
        padding: 8px;
      }
      .thumb img {
        width: 100%;
        display: block;
      }
      .final {
        background: #0f1115;
        border: 1px solid #3a4750;
        border-radius: 12px;
        padding: 16px;
      }
      .final h3 {
        margin-top: 0;
        margin-bottom: 16px;
      }
      .hidden {
        display: none;
      }
      .code {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          monospace;
        font-size: 11px;
        max-height: 120px;
        overflow-y: auto;
        background: #0b0c10;
        border: 1px solid #3a4750;
        border-radius: 6px;
        padding: 8px;
        margin-top: 8px;
        white-space: pre-wrap;
        line-height: 1.5;
        color: #c9d1d9;
        scroll-behavior: smooth;
      }
      .code::-webkit-scrollbar {
        width: 6px;
      }
      .code::-webkit-scrollbar-track {
        background: #1f2833;
        border-radius: 3px;
      }
      .code::-webkit-scrollbar-thumb {
        background: #3a4750;
        border-radius: 3px;
      }
      .code::-webkit-scrollbar-thumb:hover {
        background: #66fcf1;
      }
      .flowchart {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        padding: 20px 24px;
        background: #1a1d23;
        border-bottom: 1px solid #3a4750;
      }
      .step {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 16px;
        border-radius: 20px;
        background: #0f1115;
        border: 2px solid #3a4750;
        color: #9aa5b1;
        font-size: 13px;
        font-weight: 600;
        transition: all 0.3s ease;
        min-width: 140px;
        justify-content: center;
      }
      .step.active {
        background: #66fcf1;
        border-color: #66fcf1;
        color: #0b0c10;
        transform: scale(1.05);
        box-shadow: 0 4px 12px rgba(102, 252, 241, 0.3);
      }
      .step.completed {
        background: #45b7b8;
        border-color: #45b7b8;
        color: #ffffff;
      }
      .step-icon {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: currentColor;
        opacity: 0.7;
        transition: all 0.3s ease;
      }
      .step.active .step-icon,
      .step.completed .step-icon {
        opacity: 1;
      }
      .step-arrow {
        color: #3a4750;
        font-size: 16px;
        font-weight: bold;
      }

      /* Upload Modal Styles */
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(4px);
      }
      .modal-content {
        background: #0f1115;
        margin: 5% auto;
        padding: 24px;
        border: 1px solid #3a4750;
        border-radius: 12px;
        width: 80%;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        position: relative;
      }
      .modal h2 {
        margin-top: 0;
        color: #66fcf1;
        text-align: center;
      }
      .close {
        color: #9aa5b1;
        float: right;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
        position: absolute;
        right: 16px;
        top: 16px;
      }
      .close:hover {
        color: #66fcf1;
      }
      .character-upload-item {
        background: #1a1d23;
        border: 1px solid #3a4750;
        border-radius: 8px;
        padding: 16px;
        margin-bottom: 16px;
        display: flex;
        align-items: center;
        gap: 16px;
      }
      .character-preview {
        width: 80px;
        height: 80px;
        border-radius: 8px;
        background: #0b0c10;
        border: 1px solid #3a4750;
        object-fit: cover;
      }
      .character-info {
        flex: 1;
      }
      .character-info h4 {
        margin: 0 0 8px 0;
        color: #eaeaea;
      }
      .character-info .filename {
        font-size: 12px;
        color: #9aa5b1;
        font-family: monospace;
      }
      .file-input-wrapper {
        position: relative;
        display: inline-block;
      }
      .file-input-wrapper input[type="file"] {
        position: absolute;
        opacity: 0;
        width: 100%;
        height: 100%;
        cursor: pointer;
      }
      .file-input-button {
        background: #66fcf1;
        border: none;
        color: #0b0c10;
        font-weight: 600;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s ease;
        display: inline-block;
      }
      .file-input-button:hover {
        background: #45b7b8;
      }
      .upload-status {
        margin-top: 8px;
        font-size: 12px;
      }
      .upload-status.success {
        color: #45b7b8;
      }
      .upload-status.error {
        color: #e74c3c;
      }
      .modal-footer {
        text-align: center;
        margin-top: 24px;
        padding-top: 16px;
        border-top: 1px solid #3a4750;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>BananaVerse</h1>
      <div class="status" id="status">Idle</div>
      <div
        class="comic-title"
        id="comicTitle"
        style="
          display: none;
          font-size: 18px;
          font-weight: bold;
          color: #2c5aa0;
          margin-top: 8px;
          text-align: center;
        "
      ></div>
    </header>
    <div class="flowchart">
      <div class="step" id="step-story">
        <div class="step-icon"></div>
        <span>Enter Story</span>
      </div>
      <div class="step-arrow">‚Üí</div>
      <div class="step" id="step-characters">
        <div class="step-icon"></div>
        <span>Generate Characters</span>
      </div>
      <div class="step-arrow">‚Üí</div>
      <div class="step" id="step-scenes">
        <div class="step-icon"></div>
        <span>Generate Scenes</span>
      </div>
      <div class="step-arrow">‚Üí</div>
      <div class="step" id="step-panels">
        <div class="step-icon"></div>
        <span>Generate Panels</span>
      </div>
    </div>
    <div class="container">
      <div class="panel">
        <h3>Story Input</h3>
        <div class="row" style="margin-top: 0; margin-bottom: 12px">
          <label
            style="
              display: flex;
              align-items: center;
              gap: 8px;
              margin-bottom: 0;
            "
          >
            <input
              type="radio"
              name="inputMode"
              id="manualMode"
              value="manual"
              checked
              style="margin: 0"
            />
            <span>Enter Story Manually</span>
          </label>
          <label
            style="
              display: flex;
              align-items: center;
              gap: 8px;
              margin-bottom: 0;
            "
          >
            <input
              type="radio"
              name="inputMode"
              id="generateMode"
              value="generate"
              style="margin: 0"
            />
            <span>Generate Story with AI</span>
          </label>
        </div>
        <textarea
          id="story"
          placeholder="Paste or write your story here..."
        ></textarea>
        <div class="row">
          <button id="startBtn">Generate</button>
          <span class="status" id="runInfo"></span>
        </div>
        <div class="status code" id="log"></div>
        <div class="assets">
          <div>
            <label>Characters</label>
            <select id="charSelect"></select>
            <div id="charView" class="thumb hidden"></div>
          </div>
          <div>
            <label>Scenes</label>
            <select id="sceneSelect"></select>
            <div id="sceneView" class="thumb hidden"></div>
          </div>
        </div>
      </div>
      <div>
        <div class="final">
          <h3>Combined Output</h3>
          <img id="finalImg" alt="final" />
          <div class="grid" id="panelsGrid"></div>
        </div>
      </div>
    </div>

    <!-- Sprite Upload Modal -->
    <div id="spriteUploadModal" class="modal">
      <div class="modal-content">
        <span class="close" id="closeModal">&times;</span>
        <h2>üé® Upload Custom Character Sprites</h2>
        <p style="text-align: center; color: #9aa5b1; margin-bottom: 24px">
          Replace any character sprite with your own image. Images will be
          automatically resized and formatted.
        </p>
        <div id="charactersUploadList">
          <!-- Character upload items will be populated here -->
        </div>
        <div class="modal-footer">
          <button
            id="continueGeneration"
            class="file-input-button"
            style="padding: 12px 24px; font-size: 14px"
          >
            Continue Generation
          </button>
        </div>
      </div>
    </div>

    <script>
      const statusEl = document.getElementById("status");
      const logEl = document.getElementById("log");
      const runInfoEl = document.getElementById("runInfo");
      const comicTitleEl = document.getElementById("comicTitle");
      const startBtn = document.getElementById("startBtn");
      const storyEl = document.getElementById("story");
      const finalImg = document.getElementById("finalImg");
      const panelsGrid = document.getElementById("panelsGrid");
      const charSelect = document.getElementById("charSelect");
      const sceneSelect = document.getElementById("sceneSelect");
      const charView = document.getElementById("charView");
      const sceneView = document.getElementById("sceneView");
      const manualMode = document.getElementById("manualMode");
      const generateMode = document.getElementById("generateMode");

      // Upload modal elements
      const spriteUploadModal = document.getElementById("spriteUploadModal");
      const closeModal = document.getElementById("closeModal");
      const continueGeneration = document.getElementById("continueGeneration");
      const charactersUploadList = document.getElementById(
        "charactersUploadList"
      );

      let currentRun = null;
      let manifest = null;
      let currentStep = 0; // 0: story, 1: characters, 2: scenes, 3: panels

      const steps = [
        { id: "step-story", name: "story" },
        { id: "step-characters", name: "characters" },
        { id: "step-scenes", name: "scenes" },
        { id: "step-panels", name: "panels" },
      ];

      let logLines = [];
      const MAX_LOG_LINES = 15; // Keep only the most recent 15 lines

      // Mode switching logic
      function updateInputMode() {
        if (generateMode.checked) {
          storyEl.placeholder =
            "Describe what kind of story you want (e.g., 'write a story about a detective solving a mysterious case')...";
        } else {
          storyEl.placeholder = "Paste or write your story here...";
        }
      }

      manualMode.addEventListener("change", updateInputMode);
      generateMode.addEventListener("change", updateInputMode);

      function log(line, type = "info") {
        const timestamp = new Date().toLocaleTimeString();
        const formattedLine = `[${timestamp}] ${line}`;

        logLines.push(formattedLine);

        // Keep only the most recent lines
        if (logLines.length > MAX_LOG_LINES) {
          logLines = logLines.slice(-MAX_LOG_LINES);
        }

        // Update the display
        logEl.textContent = logLines.join("\n");

        // Auto-scroll to bottom with a small delay to ensure content is rendered
        setTimeout(() => {
          logEl.scrollTop = logEl.scrollHeight;
        }, 10);
      }

      function updateStepUI() {
        steps.forEach((step, index) => {
          const element = document.getElementById(step.id);
          element.classList.remove("active", "completed");

          if (index < currentStep) {
            element.classList.add("completed");
          } else if (index === currentStep) {
            element.classList.add("active");
          }
        });
      }

      function setCurrentStep(stepIndex) {
        currentStep = stepIndex;
        updateStepUI();
      }

      function advanceToNextStep() {
        if (currentStep < steps.length - 1) {
          currentStep++;
          updateStepUI();
        }
      }

      function toURL(path) {
        return `/api/file?run=${encodeURIComponent(
          currentRun
        )}&path=${encodeURIComponent(path)}`;
      }

      function renderAssets() {
        if (!manifest) return;
        // Characters
        charSelect.innerHTML = "";
        if (manifest.characters && manifest.characters.length) {
          const opt0 = document.createElement("option");
          opt0.value = "";
          opt0.textContent = "‚Äî select ‚Äî";
          charSelect.appendChild(opt0);
          for (const c of manifest.characters) {
            const opt = document.createElement("option");
            opt.value = c.file;
            opt.textContent = c.name;
            charSelect.appendChild(opt);
          }
        }
        // Scenes
        sceneSelect.innerHTML = "";
        if (manifest.scenes && manifest.scenes.length) {
          const opt0 = document.createElement("option");
          opt0.value = "";
          opt0.textContent = "‚Äî select ‚Äî";
          sceneSelect.appendChild(opt0);
          for (const s of manifest.scenes) {
            const opt = document.createElement("option");
            opt.value = s.file;
            opt.textContent = s.name;
            sceneSelect.appendChild(opt);
          }
        }
      }

      function renderPanels() {
        if (!manifest || !manifest.panels) return;
        panelsGrid.innerHTML = "";
        for (const p of manifest.panels) {
          const div = document.createElement("div");
          div.className = "thumb";
          const img = document.createElement("img");
          img.src = toURL(p.file) + "&_ts=" + Date.now();
          const cap = document.createElement("div");
          cap.className = "status";
          cap.textContent = `#${p.index}`;
          div.appendChild(img);
          div.appendChild(cap);
          panelsGrid.appendChild(div);
        }
      }

      function refreshFinal() {
        finalImg.src = toURL("comic_final.png") + "&_ts=" + Date.now();
      }

      async function fetchManifest() {
        if (!currentRun) return;
        try {
          const r = await fetch(
            `/api/manifest?run=${encodeURIComponent(currentRun)}`
          );
          const j = await r.json();
          if (j && Object.keys(j).length) {
            manifest = j;
            renderAssets();
            renderPanels();
          }
        } catch (e) {
          // ignore
        }
      }

      function startStream() {
        const es = new EventSource("/api/stream");
        es.onmessage = (e) => {
          try {
            const data = JSON.parse(e.data);
            if (data.type === "start") {
              statusEl.textContent = "...";
              log("Run started");
              setCurrentStep(1); // Move to characters step
            } else if (data.type === "step") {
              // Handle step start events
              statusEl.textContent = data.message || "Processing...";
              log(data.message || `Starting step: ${data.step}`);

              // Map step names to our UI steps - only advance when asset generation starts
              const stepMap = {
                story_generation: 0, // Keep on story step during generation
                characters: 1,
                scenes: 1, // Stay on characters step - don't advance until character assets complete
                character_refs: 1, // Stay on characters step until character assets complete
                scene_refs: 2, // Stay on scenes step until scene assets complete
                panels: 3,
                final: 3, // Final is part of panels
              };

              if (stepMap[data.step] !== undefined) {
                setCurrentStep(stepMap[data.step]);
              }
            } else if (data.type === "step_progress") {
              // Handle step progress events
              statusEl.textContent = `${data.item || "Processing"} (${
                data.current
              }/${data.total})`;
              log(
                `${data.item || "Processing"} (${data.current}/${data.total})`
              );
            } else if (data.type === "step_complete") {
              // Handle step completion events
              log(`Completed: ${data.message || data.step}`);

              // Advance to next step when appropriate - only after generation completes
              const stepMap = {
                story_generation: () => {}, // Stay on story step until characters start
                title_generation: () => {
                  // Display the title immediately when generated
                  if (
                    data.message &&
                    data.message.includes("Title generated:")
                  ) {
                    const title = data.message.replace("Title generated: ", "");
                    comicTitleEl.textContent = title;
                    comicTitleEl.style.display = "block";
                  }
                },
                characters: () => {}, // Don't advance yet, wait for character_refs
                scenes: () => {}, // Don't advance yet, wait for scene_refs
                character_refs: () => setCurrentStep(2), // Now move to scenes after character generation
                scene_refs: () => setCurrentStep(3), // Now move to panels after scene generation
                final: () => {}, // Stay on panels (will be completed in done event)
              };

              if (stepMap[data.step]) {
                stepMap[data.step]();
              }
            } else if (data.type === "progress") {
              if (data.files && data.files.length) {
                log("Files: " + data.files.join(", "));
                fetchManifest();
                // Re-render panels after each update to show new panels immediately
                setTimeout(renderPanels, 100);
              }
              if (data.final) {
                refreshFinal();
              }
            } else if (data.type === "assets") {
              // Minimal assets update before manifest
              if (!manifest)
                manifest = { characters: [], scenes: [], panels: [] };
              if (Array.isArray(data.characters)) {
                manifest.characters = data.characters;
              }
              if (Array.isArray(data.scenes)) {
                manifest.scenes = data.scenes;
              }
              renderAssets();
            } else if (data.type === "comic_rebuilt") {
              // Refresh the combined output when comic is rebuilt
              refreshFinal();
              log("Comic rebuilt with latest content");
            } else if (data.type === "manifest") {
              manifest = data.manifest;
              renderAssets();
              renderPanels();
            } else if (data.type === "sprite_upload_ready") {
              // Show the sprite upload modal
              log("Character sprites ready - showing upload options");
              showSpriteUploadModal(data.characters);
            } else if (data.type === "sprite_uploaded") {
              // Handle sprite upload confirmation
              log(`Sprite updated: ${data.filename}`);
              // Refresh character assets display
              fetchManifest();
            } else if (data.type === "waiting_for_user") {
              // Handle waiting for user to continue
              statusEl.textContent = "Waiting for you to continue...";
              log(data.message || "Waiting for user input");
            } else if (data.type === "done") {
              statusEl.textContent = "Completed";
              refreshFinal();
              startBtn.disabled = false;
              startBtn.textContent = "Generate";
              startBtn.classList.remove("generating");
              es.close();
            } else if (data.type === "error") {
              statusEl.textContent = "Error";
              log("Error: " + data.message);
              startBtn.disabled = false;
              startBtn.textContent = "Generate";
              startBtn.classList.remove("generating");
              es.close();
            }
          } catch (err) {
            // ignore malformed lines
          }
        };
        es.onerror = () => {
          es.close();
        };
      }

      startBtn.addEventListener("click", async () => {
        const input = storyEl.value.trim();
        if (!input) return;
        startBtn.disabled = true;
        startBtn.textContent = "Generating...";
        startBtn.classList.add("generating");
        statusEl.textContent = "...";
        logLines = []; // Clear log lines array
        logEl.textContent = "";
        finalImg.removeAttribute("src");
        panelsGrid.innerHTML = "";
        charSelect.innerHTML = "";
        sceneSelect.innerHTML = "";
        charView.classList.add("hidden");
        sceneView.classList.add("hidden");
        comicTitleEl.style.display = "none"; // Hide title when starting new generation
        manifest = null;
        setCurrentStep(0); // Reset to story step
        try {
          const requestBody = generateMode.checked
            ? { user_input: input, generate_story: true }
            : { story: input };

          const r = await fetch("/api/start", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestBody),
          });
          const j = await r.json();
          if (j.run) {
            currentRun = j.run;
            runInfoEl.textContent = currentRun;
            startStream();
          } else {
            statusEl.textContent = "Failed to start";
          }
        } catch (e) {
          statusEl.textContent = "Failed to start";
          startBtn.disabled = false;
          startBtn.textContent = "Generate";
          startBtn.classList.remove("generating");
        }
      });

      charSelect.addEventListener("change", () => {
        const path = charSelect.value;
        if (!path) {
          charView.classList.add("hidden");
          return;
        }
        charView.innerHTML = `<img src="${toURL(path)}&_ts=${Date.now()}" />`;
        charView.classList.remove("hidden");
      });

      sceneSelect.addEventListener("change", () => {
        const path = sceneSelect.value;
        if (!path) {
          sceneView.classList.add("hidden");
          return;
        }
        sceneView.innerHTML = `<img src="${toURL(path)}&_ts=${Date.now()}" />`;
        sceneView.classList.remove("hidden");
      });

      // Initialize step UI on page load
      updateStepUI();

      // Initialize input mode
      updateInputMode();

      // Upload modal functions
      function showSpriteUploadModal(characters) {
        charactersUploadList.innerHTML = "";

        characters.forEach((char) => {
          const item = document.createElement("div");
          item.className = "character-upload-item";
          item.innerHTML = `
            <img src="${toURL(
              `characters/${char.filename}`
            )}&_ts=${Date.now()}" 
                 class="character-preview" alt="${char.name}">
            <div class="character-info">
              <h4>${char.name}</h4>
              <div class="filename">${char.filename}</div>
              <div class="file-input-wrapper">
                <input type="file" accept=".png,.jpg,.jpeg" data-filename="${
                  char.filename
                }">
                <span class="file-input-button">Choose New Sprite</span>
              </div>
              <div class="upload-status" data-filename="${char.filename}"></div>
            </div>
          `;
          charactersUploadList.appendChild(item);
        });

        spriteUploadModal.style.display = "block";
      }

      function closeSpriteUploadModal() {
        spriteUploadModal.style.display = "none";
      }

      async function uploadSprite(file, filename) {
        const statusEl = document.querySelector(
          `[data-filename="${filename}"]`
        );
        statusEl.textContent = "Uploading...";
        statusEl.className = "upload-status";

        const formData = new FormData();
        formData.append("file", file);
        formData.append("run", currentRun);
        formData.append("filename", filename);

        try {
          const response = await fetch("/api/upload_sprite", {
            method: "POST",
            body: formData,
          });

          const result = await response.json();

          if (result.success) {
            statusEl.textContent = "‚úì Uploaded successfully";
            statusEl.className = "upload-status success";

            // Update the preview image
            const previewImg = document.querySelector(
              `img[alt="${filename.replace(".png", "")}"]`
            );
            if (previewImg) {
              previewImg.src =
                toURL(`characters/${filename}`) + "&_ts=" + Date.now();
            }

            log(`Sprite uploaded: ${filename}`);
          } else {
            statusEl.textContent = "‚úó " + result.error;
            statusEl.className = "upload-status error";
          }
        } catch (error) {
          statusEl.textContent = "‚úó Upload failed";
          statusEl.className = "upload-status error";
          console.error("Upload error:", error);
        }
      }

      // Modal event listeners
      closeModal.addEventListener("click", closeSpriteUploadModal);
      continueGeneration.addEventListener("click", async () => {
        // Signal the backend to continue generation
        try {
          const response = await fetch("/api/continue_generation", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ run: currentRun }),
          });
          const result = await response.json();
          if (result.success) {
            log("Continuing generation...");
          } else {
            log("Error continuing generation: " + result.error);
          }
        } catch (error) {
          log("Failed to continue generation");
          console.error("Continue error:", error);
        }
        closeSpriteUploadModal();
      });

      // Close modal when clicking outside
      window.addEventListener("click", (event) => {
        if (event.target === spriteUploadModal) {
          closeSpriteUploadModal();
        }
      });

      // Handle file uploads
      document.addEventListener("change", (event) => {
        if (event.target.type === "file" && event.target.dataset.filename) {
          const file = event.target.files[0];
          if (file) {
            uploadSprite(file, event.target.dataset.filename);
          }
        }
      });
    </script>
  </body>
</html>
